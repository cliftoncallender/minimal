<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>numpy_scipy_matplotlib.py</title>
  <link rel="stylesheet" href="pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'><h1>numpy_scipy_matplotlib.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      <h2><span id="examples-with-numpy,-scipy,-and-matplotlib" href="examples-with-numpy,-scipy,-and-matplotlib"> Examples with numpy, scipy, and matplotlib</h2>
<p></span></p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span></span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>Original code is <a href="numpy_scipy_matplotlib.py">here</a>.</p>
<h1>==== NumPy ====</h1>
<h1>Imports the <code>numpy</code> library as the name <code>np</code>. This is a very common convention.</h1>
<p>import numpy as np</p>
<h1>Comparing Python lists and NumPy arrays.</h1>
<h1>a_list is a Python list</h1>
<p>a_list = [1, 2, 3, 4, 5]
print('a_list is type', type(a_list))</p>
<h1>a_array is a NumPy array</h1>
<p>a_array = np.array(a_list)
print('a_array is type', type(a_array))</p>
<h1>Can create Numpy arrays from a Python list and vice-versa</h1>
<p>b_array = np.array([3, 2, 4, 1, 5])
b_list = list(b_array)</p>
<h1>The <code>+</code> operator concatenates two lists</h1>
<p>print('a_list + b_list =', a_list + b_list)</p>
<h1>The <code>+</code> operator performs pairwise component addition for two arrays</h1>
<p>print('a_array + b_array =', a_array + b_array)</p>
<h1>The <code>+</code> operator can also add a scalar to an array</h1>
<p>print('a_array + 5 =', a_array + 5)</p>
<h1>Similarly, <code>*</code> will perform pairwise component multiplication</h1>
<p>print('a_array * b_array = ', a_array * b_array)</p>
<h1>Remember that when applied to a list and a scaler</h1>
<h1><code>*</code> will perform multiple concatenations</h1>
<p>print('a_list * 3 =', a_list * 3)</p>
<h1>When applied to two lists, however, <code>*</code> yields</h1>
<h1><code>TypeError: can't multiply sequence by non-int of type 'list'</code></h1>
<h1>print('a_list * b_list =', a_list * b_list)</h1>
<h1>==== SciPy ====</h1>
<h1>Importing the <code>pearsonr</code> method from the <code>scipy.stats.stats</code> module.</h1>
<h1><code>scipy</code> builds on <code>numpy</code>.</h1>
<p>from scipy.stats.stats import pearsonr</p>
<h1>eight lists and their correlations</h1>
<p>a = [1, 2, 3, 4, 5] # initial list
b = [1, 2, 3, 4, 5] # identical to <code>a</code>
c = [0, 1, 2, 3, 4] # identical to <code>a</code> minus 1
d = [2, 4, 6, 8, 10] # identical to <code>a</code> * 2
e = [1, 2, 3, 5, 4] # very similar, but not identical to <code>a</code>
f = [1, 5, 4, 2, 3] # not similar to <code>a</code>
g = [5, 4, 3, 2, 1] # opposite of <code>a</code>
h = [1, 1, 1, 1, 1] # flat shape; standard deviation of <code>h</code> is 0</p>
<h1>Correlations between <code>a</code> and the other lists:</h1>
<p>comparisons = [b, c, d, e, f, g, h]
for comparison in comparisons:
    # <code>pearsonr</code> returns a tuple corresponding to the r and p values
    corr, p = pearsonr(a, comparison)</p>
<pre><code># Correlation between `a` and `b`, `c`, and `d` is 1.0 (maximal).  
# Correlation between `a` and `e` is 0.9 (high, but not maximal).  
# Correlation between `a` and `f` is 0.1, indicating almost no correlation.  
# Correlation between `a` and `g` is -1.0,indicating a maximal inverse
# inverse correlation.  
# Correlation between `a` and `h` is `nan` (not a number), since the
# calculation of correlation involves division by the standard deviations
# (which for `h` is 0).
print('Correlation between', a, 'and', comparison, ':', corr)
</code></pre>
<h1>== Using scipy distance measures in music ==</h1>
<h1><code>harmonic_distance</code> measures the Euclidean distance between two interval</h1>
<h1>vectors. This is identical to Richard Teitelbaum's "similarity index".</h1>
<h1>You can substitute different distance measures from the</h1>
<h1><code>scipy.spatial.distance</code> module. For instance, using <code>cityblock</code> distance</h1>
<h1>recreates Robert Morris' "SIM" measure.</h1>
<p>def harmonic_distance(p, q):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="sb">`p`</span> <span class="ow">and</span> <span class="sb">`q`</span> <span class="n">are</span> <span class="n">lists</span> <span class="n">of</span> <span class="n">pitches</span><span class="o">.</span> <span class="sb">`harmonic_distance`</span> <span class="n">depends</span> <span class="n">on</span>
    <span class="n">music21</span> <span class="ow">and</span> <span class="n">scipy</span><span class="o">.</span>

    <span class="n">Returns</span> <span class="n">the</span> <span class="n">harmonic</span> <span class="n">distance</span> <span class="n">of</span> <span class="sb">`p`</span> <span class="ow">and</span> <span class="sb">`q`</span> <span class="n">interpreted</span> <span class="k">as</span> <span class="n">chords</span> <span class="n">based</span> <span class="n">on</span>
    <span class="n">the</span> <span class="n">Euclidean</span> <span class="n">distance</span> <span class="kn">from</span> <span class="nn">the</span> <span class="sb">`scipy.spatial.distance`</span> <span class="n">module</span><span class="o">.</span> <span class="n">Prints</span> <span class="n">an</span>
    <span class="n">error</span> <span class="n">message</span> <span class="ow">and</span> <span class="n">returns</span> <span class="sb">`None`</span> <span class="k">if</span> <span class="n">the</span> <span class="n">lists</span> <span class="n">are</span> <span class="n">of</span> <span class="n">unequal</span> <span class="n">length</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      <p>from music21 import chord
from scipy.spatial import distance</p>
<p>if len(p) != len(q):
    print('lists of pitches are of unequal lengths')
    return None</p>
<h1>Using the <code>music21</code> <code>Chord</code> class <code>.intervalVector</code> property</h1>
<p>iv_p = chord.Chord(p).intervalVector
iv_q = chord.Chord(q).intervalVector
return distance.euclidean(iv_p, iv_q)</p>
<h1>Using <code>harmonic_distance</code> to compare the harmonic similarity of three</h1>
<h1><code>chords</code></h1>
<p>chords =  [0, 2, 3, 7], [0, 2, 4, 6], <a href="0, 2, 3, 7], [0, 2, 4, 6], [0, 4, 8, 11.html">0, 4, 8, 11</a>
print('Harmonic distances')
for i in range(2):
u = chords[i]
for j in range(i+1, 3):
    v = chords[j]
    print(u, '&lt;--&gt;', v, ':', harmonic_distance(u, v))</p>
<h1>==== Matplotlib ====</h1>
<h1><code>pyplot</code> is a module in <code>matplotlib</code>  for plotting. `matplotlib depends on</h1>
<h1><code>numpy</code>. See https://matplotlib.org/api/pyplot_api.html for more details.</h1>
<p>import matplotlib.pyplot as plt</p>
<h1>plotting two lists on the plane</h1>
<p>x = [1, 2, 3, 4, 5]
y = [1, 7, 4, 2, 3]
plt.plot(x, y)</p>
<h1>plot should automatically open</h1>
<p>plt.show()</p>
<h1><code>arange</code> is the <code>numpy</code> array equivalent of Python's built-in <code>range</code></h1>
<h1>function.</h1>
<p>x = np.arange(20)
print('x is', x)</p>
<h1>plot f(x) = x**2</h1>
<p>print('x squared is', x<strong>2)
plt.plot(x, x</strong>2)
plt.show()</p>
<h1>plot f(x) = sin(2Ï€x/20) using <code>numpy</code>'s <code>sin</code> function and <code>pi</code> constant</h1>
<p>y = np.sin(x * 2 * np.pi / len(x))
plt.plot(x, y)
plt.show()</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
